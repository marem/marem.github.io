{"title":"Creating generative art with L-systems in Python","markdown":{"yaml":{"title":"Creating generative art with L-systems in Python","subtitle":"Some experiments on the algorithmic beauty of plants","description":"Would it be possible to create a Python project that can generate those pencil-like drawings with random forests, with different types of trees?\", I thought (pun intended). Of course, someone already thought of that and it even has a name: algorithmic botany.\n","date":"2021-04-26","date-format":"MMM YYYY","image":"/images/lartpy.jpg","categories":["english","visualization","generative art","coding"]},"headingText":"Playing with L-systems in Python","containsRefs":false,"markdown":"\n\n![](/images/lartpy.jpg)\n\n[Creative coding](https://en.wikipedia.org/wiki/Creative_coding) is fun if you know a thing or two about programming. And if, like me, you are an utter noob when it comes to brushes and pencils, then it is even more enticing as a means to express yourself and create something just for the sake of it. It doesn't have to be functional, but you do get to hone your hacking skills and set challenges for yourself along the way.\n\nA fellow data scientist who is into [\"Art & AI\"](https://www.basbloemberg.nl/) recently pointed me to the field of [generative art](https://aiartists.org/generative-art-design). I have always been facinated by [emergence](https://en.wikipedia.org/wiki/Emergence) and even more so when I came across the picture above. It is featured in [this blog](https://g-e-n-a-r-t.com/en/post.php?p=10) on how to draw a pencil-sketch-like forest with Processing. One thing led to another: I had a go at [Processing in Python mode](https://py.processing.org/tutorials/command-line/), dabbled with [matplotlib for animations](http://louistiao.me/posts/notebooks/embedding-matplotlib-animations-in-jupyter-as-interactive-javascript-widgets/) and read Schiffman's [the Nature of Code](https://natureofcode.com/book/).\n\n_\"Would it be possible to create a Python project that can generate those pencil-like drawings with random forests, with different types of trees?\"_, I thought (pun intended). Of course, someone already thought of that and it even has a name: __algorithmic botany__. Przemyslaw Prusinkiewicz and Aristid Lindenmayer wrote the seminal book on the subject in 1990, [The Algorithmic Beauty of Plants](http://algorithmicbotany.org/papers/#abop). Lindenmayer invented [L-systems](https://en.wikipedia.org/wiki/L-system) already back in 1968. Today, household computers have enough resources to handle large-ish parallel writing systems and you could start modelling the growth of any plant using a framework like [L-Py](https://lpy.readthedocs.io/en/latest/).\n\nAlthough a lot has been written on the subject and there are quite a few open source libraries, they weren't quite what I have in mind. Instead, the idea of creating generative art in Python emerged using the following components:\n\n1. A lightweight implementation of L-systems that also supports stochastic and parametric production rules;\n2. Integration with [p5js](https://p5js.org) via [pyp5js](https://berinhard.github.io/pyp5js/) as a web-native graphing engine.\n\nThe possibilities are endless and I can foresee spending way too much time on this. In this blog post, I will lay out the ideas behind this approach.\n\n\nThere are different kinds of L-systems, with increasing complexity. We will start with the simplest: Lindenmayer's original L-system for modelling the growth of algae (We will jump right in, please read the [article on Wikipedia](https://en.wikipedia.org/wiki/L-system) if you need more context).\n\n## D0L: deterministic context-free L-system\n\n\nI actually found the recursive Python implementation on this [introductory website on recursion](https://understanding-recursion.readthedocs.io/en/latest/16%20L-System%20Solution.html). While I still struggle to apply recursion, I find it satisfying to solve coding problems this way. And even with just these twenty lines of code, we have already stumbled on the [Fibonacci numbers](https://en.wikipedia.org/wiki/Fibonacci_number)! Have a look at the length of each successive sequence:\n\n\nAwesome as the nature of code may be, we are still a long way off from actually generating a tree. For that, we need branching rules. To do so, basic L-systems also allow constants, which are left untouched by the production rules. It is common to add constants `+` and `-` to denote rotations when branching, and `[`,`]` for handling the locations of the branching points. For a fractal plant, the code is as follows:\n\nIt is amazing to see how complexity increases by adding slightly longer rules. To actually draw something, we translate the letters as follows:\n* \"F\" means \"draw forward\"\n* \"-\" means \"turn right\", using a predefined value e.g. 30°\n* \"+\" means \"turn left 30°\"\n* \"X\" does not correspond to any drawing action and is used to control the evolution of the curve.\n\nThe square bracket \"\\[\" corresponds to saving the current values for position and angle, which are restored when the corresponding \"]\" is executed, which effectively is a [LIFO stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)). We will go into the details of how to draw later.\n\n## Adding stochastic rules\n\nD0L systems are completely deterministic, that is, each starting axiom yields the same result. Using this to draw a forest would result in a boring scene: all trees would be identical. To mimic mutations in nature, stochastic L-systems allow the same letter to have for different production rules with a given probability. For example, if we want three different production rules for F with equal probability\n\n```\np1: F(0.33) → F[+F]F[−F]F\np2: F(0.33) → F[+F]F\np3: F(0.34) → F[−F]F\n```\n\nthe Python implementation could look something like this:\n\nHere's another run with a different result:\n\n## Adding parameters\n\nIn a parametric L-system, letters are allowed to have parameters, which correspond with formal parameters used in the specification of L-system productions. This can be used to model _Anabaena catenula_ (taken from [Hanan's dissertation](http://algorithmicbotany.org/papers/hanan.dis1992.html)):\n\n\nWhile the _Anabaena_ example above only makes simple comparisons, parametric L-systems can use any expression using the parameters in combination with the arithmetic operators +, −, ∗, /; the exponentiation operator ∧, the relational operators <, >, =; the logical operators !, &, | (not, and, or) etc. For example, we could define a parameter `time` which increases with every iteration. This could be used to thicken the width of a branch of a tree.\n\n\n# Using pyp5js for Pythonic drawing on the web\n\nWhen Lindenmayer devised the L-system, [Logo](https://en.wikipedia.org/wiki/Logo_(programming_language)) was one of the few programming langauges available. It  included [turtle graphics](https://en.wikipedia.org/wiki/Turtle_graphics) and thus the basis of algorithmic art was born by translating the alphabet of an L-system to turtle commands. The examples from the Nature of Code have in fact [implemented this in Processing](https://github.com/nature-of-code/noc-examples-processing/blob/master/chp08_fractals/NOC_8_09_LSystem/Turtle.pde). But rather than constrain yourself to the desktop, more mileage can be had by using [p5js](https://p5js.org) which is \"... an interpretation of Processing for today's web\". To demonstrate, take the following example:\n\nSummer Rizo has already implemented L-systems in p5js, available on [thefractal.zone](https://thefractal.zone/). Copying the axiom and rules, and setting the branching angle $\\theta$ to 30°, yields the drawing below. Note that the code only shows 5 iterations, while the drawing is based on more iterations (I have put the slider on maximum). When using recursion in Python you may quickly hit a limit: as I tried to execute `iterations=10` on a standard VM, Deepnote threw an error `IOPub data rate exceeded`. Yet another challenge to read-up and use [tail-call optimization in Python](https://sagnibak.github.io/blog/python-is-haskell-tail-recursion/).\n\n![](/images/fractal.png)\n\nHaving covered the algorithmic and technical components, we can now start bringing it all together. There are still quite a few things to experiment with in order to produce realistic sketches, such as adding noise to draw 'sketchy' lines, adding thickness to branches, adding shadows with brightness off-sets and composing a scene with overlaying trees. As a Pythonista I was happy to find [pyp5js](https://berinhard.github.io/pyp5js/), which allows you to re-use the ideas of Processing in Python, and transcoding it to p5.js using Transcrypt. It covers all the methods from p5.js and gives us enough drawing tools to play with. But that's for another post. For now, I will leave you with a [generative creation from Anders Hoff](https://inconvergent.net/generative/) which may inspire you to start creating generative art in Python, too.\n\n![](/images/tree2.gif)\n","srcMarkdownNoYaml":"\n\n![](/images/lartpy.jpg)\n\n[Creative coding](https://en.wikipedia.org/wiki/Creative_coding) is fun if you know a thing or two about programming. And if, like me, you are an utter noob when it comes to brushes and pencils, then it is even more enticing as a means to express yourself and create something just for the sake of it. It doesn't have to be functional, but you do get to hone your hacking skills and set challenges for yourself along the way.\n\nA fellow data scientist who is into [\"Art & AI\"](https://www.basbloemberg.nl/) recently pointed me to the field of [generative art](https://aiartists.org/generative-art-design). I have always been facinated by [emergence](https://en.wikipedia.org/wiki/Emergence) and even more so when I came across the picture above. It is featured in [this blog](https://g-e-n-a-r-t.com/en/post.php?p=10) on how to draw a pencil-sketch-like forest with Processing. One thing led to another: I had a go at [Processing in Python mode](https://py.processing.org/tutorials/command-line/), dabbled with [matplotlib for animations](http://louistiao.me/posts/notebooks/embedding-matplotlib-animations-in-jupyter-as-interactive-javascript-widgets/) and read Schiffman's [the Nature of Code](https://natureofcode.com/book/).\n\n_\"Would it be possible to create a Python project that can generate those pencil-like drawings with random forests, with different types of trees?\"_, I thought (pun intended). Of course, someone already thought of that and it even has a name: __algorithmic botany__. Przemyslaw Prusinkiewicz and Aristid Lindenmayer wrote the seminal book on the subject in 1990, [The Algorithmic Beauty of Plants](http://algorithmicbotany.org/papers/#abop). Lindenmayer invented [L-systems](https://en.wikipedia.org/wiki/L-system) already back in 1968. Today, household computers have enough resources to handle large-ish parallel writing systems and you could start modelling the growth of any plant using a framework like [L-Py](https://lpy.readthedocs.io/en/latest/).\n\nAlthough a lot has been written on the subject and there are quite a few open source libraries, they weren't quite what I have in mind. Instead, the idea of creating generative art in Python emerged using the following components:\n\n1. A lightweight implementation of L-systems that also supports stochastic and parametric production rules;\n2. Integration with [p5js](https://p5js.org) via [pyp5js](https://berinhard.github.io/pyp5js/) as a web-native graphing engine.\n\nThe possibilities are endless and I can foresee spending way too much time on this. In this blog post, I will lay out the ideas behind this approach.\n\n# Playing with L-systems in Python\n\nThere are different kinds of L-systems, with increasing complexity. We will start with the simplest: Lindenmayer's original L-system for modelling the growth of algae (We will jump right in, please read the [article on Wikipedia](https://en.wikipedia.org/wiki/L-system) if you need more context).\n\n## D0L: deterministic context-free L-system\n\n\nI actually found the recursive Python implementation on this [introductory website on recursion](https://understanding-recursion.readthedocs.io/en/latest/16%20L-System%20Solution.html). While I still struggle to apply recursion, I find it satisfying to solve coding problems this way. And even with just these twenty lines of code, we have already stumbled on the [Fibonacci numbers](https://en.wikipedia.org/wiki/Fibonacci_number)! Have a look at the length of each successive sequence:\n\n\nAwesome as the nature of code may be, we are still a long way off from actually generating a tree. For that, we need branching rules. To do so, basic L-systems also allow constants, which are left untouched by the production rules. It is common to add constants `+` and `-` to denote rotations when branching, and `[`,`]` for handling the locations of the branching points. For a fractal plant, the code is as follows:\n\nIt is amazing to see how complexity increases by adding slightly longer rules. To actually draw something, we translate the letters as follows:\n* \"F\" means \"draw forward\"\n* \"-\" means \"turn right\", using a predefined value e.g. 30°\n* \"+\" means \"turn left 30°\"\n* \"X\" does not correspond to any drawing action and is used to control the evolution of the curve.\n\nThe square bracket \"\\[\" corresponds to saving the current values for position and angle, which are restored when the corresponding \"]\" is executed, which effectively is a [LIFO stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)). We will go into the details of how to draw later.\n\n## Adding stochastic rules\n\nD0L systems are completely deterministic, that is, each starting axiom yields the same result. Using this to draw a forest would result in a boring scene: all trees would be identical. To mimic mutations in nature, stochastic L-systems allow the same letter to have for different production rules with a given probability. For example, if we want three different production rules for F with equal probability\n\n```\np1: F(0.33) → F[+F]F[−F]F\np2: F(0.33) → F[+F]F\np3: F(0.34) → F[−F]F\n```\n\nthe Python implementation could look something like this:\n\nHere's another run with a different result:\n\n## Adding parameters\n\nIn a parametric L-system, letters are allowed to have parameters, which correspond with formal parameters used in the specification of L-system productions. This can be used to model _Anabaena catenula_ (taken from [Hanan's dissertation](http://algorithmicbotany.org/papers/hanan.dis1992.html)):\n\n\nWhile the _Anabaena_ example above only makes simple comparisons, parametric L-systems can use any expression using the parameters in combination with the arithmetic operators +, −, ∗, /; the exponentiation operator ∧, the relational operators <, >, =; the logical operators !, &, | (not, and, or) etc. For example, we could define a parameter `time` which increases with every iteration. This could be used to thicken the width of a branch of a tree.\n\n\n# Using pyp5js for Pythonic drawing on the web\n\nWhen Lindenmayer devised the L-system, [Logo](https://en.wikipedia.org/wiki/Logo_(programming_language)) was one of the few programming langauges available. It  included [turtle graphics](https://en.wikipedia.org/wiki/Turtle_graphics) and thus the basis of algorithmic art was born by translating the alphabet of an L-system to turtle commands. The examples from the Nature of Code have in fact [implemented this in Processing](https://github.com/nature-of-code/noc-examples-processing/blob/master/chp08_fractals/NOC_8_09_LSystem/Turtle.pde). But rather than constrain yourself to the desktop, more mileage can be had by using [p5js](https://p5js.org) which is \"... an interpretation of Processing for today's web\". To demonstrate, take the following example:\n\nSummer Rizo has already implemented L-systems in p5js, available on [thefractal.zone](https://thefractal.zone/). Copying the axiom and rules, and setting the branching angle $\\theta$ to 30°, yields the drawing below. Note that the code only shows 5 iterations, while the drawing is based on more iterations (I have put the slider on maximum). When using recursion in Python you may quickly hit a limit: as I tried to execute `iterations=10` on a standard VM, Deepnote threw an error `IOPub data rate exceeded`. Yet another challenge to read-up and use [tail-call optimization in Python](https://sagnibak.github.io/blog/python-is-haskell-tail-recursion/).\n\n![](/images/fractal.png)\n\nHaving covered the algorithmic and technical components, we can now start bringing it all together. There are still quite a few things to experiment with in order to produce realistic sketches, such as adding noise to draw 'sketchy' lines, adding thickness to branches, adding shadows with brightness off-sets and composing a scene with overlaying trees. As a Pythonista I was happy to find [pyp5js](https://berinhard.github.io/pyp5js/), which allows you to re-use the ideas of Processing in Python, and transcoding it to p5.js using Transcrypt. It covers all the methods from p5.js and gives us enough drawing tools to play with. But that's for another post. For now, I will leave you with a [generative creation from Anders Hoff](https://inconvergent.net/generative/) which may inspire you to start creating generative art in Python, too.\n\n![](/images/tree2.gif)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":false,"include-in-header":[{"text":""}],"output-file":"lartpy.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","jupyter":"python3","date-format":"MMM YYYY","theme":{"light":["flatly","../mozilla.scss"]},"title":"Creating generative art with L-systems in Python","subtitle":"Some experiments on the algorithmic beauty of plants","description":"Would it be possible to create a Python project that can generate those pencil-like drawings with random forests, with different types of trees?\", I thought (pun intended). Of course, someone already thought of that and it even has a name: algorithmic botany.\n","date":"2021-04-26","image":"/images/lartpy.jpg","categories":["english","visualization","generative art","coding"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}